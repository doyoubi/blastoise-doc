# 执行计划
用户输入的SQL语句被转换成解析树，并通过语义检查后，就会被转换为执行计划。生成执行计划的过程中将会有大量的优化操作。在Blastoise中为了精简，仅仅实现了生成执行计划，略去了对执行计划的转换。一般来说，执行计划仅仅适用于增删改查的操作，但在Blastoise中，为了内部实现的统一，创建表和删除表也统一用执行计划来实现。前文提到，执行计划分为逻辑执行计划和物理执行计划，对于生成这两个阶段的执行计划，会有不同的方法对逻辑执行计划和物理执行计划进行优化。为了精简，Blastoise去掉了逻辑执行计划这一环，也没有对物理执行计划做变换操作。但下面也会讲解在Blastoise的基础上，如何对执行计划做优化。下面，会先介绍迭代器，然后介绍各种迭代器的实现细节，以及它们如何一同完成增删改查的任务。然后会介绍如何从SQL解析树生成执行计划。最后会介绍一下优化的做法。

## 迭代器简介
迭代器是一种非常常用的设计模式，它为遍历操作提供了一个统一接口，隐秘了遍历细节。执行计划中最精妙的设计当属使用迭代器来实现。由于遍历细节和遍历接口得到分离，就可以使迭代器具有可随意组装的特性。迭代器都会实现一个最基本的接口，这个接口就是“取下一个值”操作。当这个取下一个值操作返回空的时候，就说明扫描任务已经结束。
这里主要拿查询操作来说明。对于SELECT * FROM STUDENTS WHERE score > 80这样的查询操作。如果是最简单的执行计划，首先需要做的操作就是对STUDENTS表进行全表扫描，这显然就是一个线性表的迭代器可以完成的。接下来需要做的就是对于每一个迭代器返回的表元组进行筛选操作，挑选出score字段大于80的表元组。筛选操作的迭代器是这样设计的，它内部保存对另外一个迭代器的引用，当它本身被要求取下一个值时，它首先要求对另一个迭代器取下一个元组操作，然后检查取到的元组是否满足筛选条件，如果不满足则继续要求另一个迭代器取下一个元组，继续筛选，直到找到一个满足筛选条件的，就返回。至此，一个全表扫描的迭代器和一个筛选迭代器就完成了这个查询操作的任务。而迭代器的可组装性质将会在接下来的各个迭代器的详细介绍中慢慢体现出来。

## 迭代器接口
Blastoise中，迭代器的接口除了有取下一个值操作，还有打开操作、关闭操作、打印相关信息操作、获取错误操作。打开操作是用于在迭代器开始前，申请一些任务需要用到的资源，例如把表数据从磁盘读入到内存池。而关闭操作则用于释放在打开操作中申请的资源，还有关闭所引用的迭代器。打印相关信息操作则用于查看一个迭代器所需要执行的任务的情况，类似于Mysql中的EXPLAIN操作。而获取错误操作是用于获取迭代器运行时发生的错误，这个错误不是指程序发生的错误，而是指一些在运行前，不能一开始就发现的错误。例如在插入一个数据的时候，有可能已经有相同主键的元组已经存在了，如果不做全表扫描，是不能发现这个错误的，因此需要有对这种错误的处理。如果一个迭代器有错误，那么它不能继续执行下去，而应该立即告诉用户操作失败了。

## 元组的具体实现
由于迭代器的实现部分牵涉到存储相关的细节，因此这里先作简要说明。元组的数据直接按字段的顺序紧凑地排列在一起，而这个数据排列结构在数据从磁盘转到内存中是不变的，因此对于元组，每个迭代器仅仅需要保存一份元组的描述，即所有字段的类型和所占空间的大小，还有该元组的指针即可。

## 各种迭代器介绍
### 全表扫描迭代器
全表扫描迭代器是最基本的迭代器，它用于查询操作。例如对于SELECT * FROM STUDENTS这样的SQL语句，就可以用一个全表扫描迭代器来实现。全表扫描迭代器的扫描操作是通过扫描内存池中的数据来实现的，因此在执行扫描之前，需要保证内存池中已经有了相关的数据。更确切来说，Blastoise的内存池是以页为单位的，整个扫描操作的基本过程是把磁盘中的数据以内存页为单位来处理，先从磁盘读一页数据进内存池，然后对该页数据做扫描，数据都扫描结束后放弃这一页然后获取下一页，再进行扫描操作。因此全表扫描迭代器的打开操作首先需要把表的第一页数据读进内存，这部分操作的细节将会在内存池部分再作详细说明。而关闭操作则需要确保把持有的内存页都全部释放。全表扫描迭代器内部需要维护一个索引值指向当前已经遍历到的元组位置，当下一次获取下一个元组时，需要根据这个索引值计算出下一个索引值是多少，并且在必要的时候要求内存池把数据从磁盘读入到内存中。接着只要把扫描得到的元组通过取下一个元组操作返回就可以了。当扫描结束时，迭代器返回空。
### 索引扫描迭代器
索引是用来加快扫描操作的一个非常有效的手段。虽然Blastoise没有实现索引，但为了展示迭代器的可组装的特性，这里需要对索引扫描迭代器作简要的接受。在查询操作中，性能的热点一般在于扫描迭代器，因为这是所有其它迭代器的数据源头，它的复杂度决定了整个查询操作的复杂度。因此关系型数据库的优化不少都是针对扫描操作的优化。建索引的基本思路是减少不必要的扫描。例如对于SELECT * FROM STUDENT WHERE ID = 5000。如果是哈希索引，则可以直接通过哈希表直接找出所找元组所在的位置。当然因为哈希文件也不小，所以载入到内存也需要一定的开销。如果是对ID这个字段做了B+树索引，由于B+树里面的元素是已经排好序的，所以首先这类似于把数组的查找转换为二叉排序树的查找。而此处优化的效果会好得多。因为扫描操作除了是费CPU外，不少时间也会用在磁盘的数据读取上。而如果使用了B+树索引，数据本身只需要读一次磁盘，因为可以通过B+树找到元组所在的位置。因此主要的磁盘消耗在于B+树数据的读取，由于B+树的性质，树的深度很浅，磁盘读取的次数也因此大大得到降低。
可见，索引扫描操作与全表扫描是实现上非常不一样，但利用了迭代器，索引扫描迭代器与全表扫描迭代器暴露了完全相同的接口，对于需要全表扫描迭代器完成的地方，完全可以把全表扫描迭代器无缝替换为索引扫描迭代器，而不用更改其它任何部分，这正体现了上述的迭代器的可组件化特性。
