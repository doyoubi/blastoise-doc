# 执行计划
用户输入的SQL语句被转换成解析树，并通过语义检查后，就会被转换为执行计划。生成执行计划的过程中将会有大量的优化操作。在Blastoise中为了精简，仅仅实现了生成执行计划，略去了对执行计划的转换。一般来说，执行计划仅仅适用于增删改查的操作，但在Blastoise中，为了内部实现的统一，创建表和删除表也统一用执行计划来实现。前文提到，执行计划分为逻辑执行计划和物理执行计划，对于生成这两个阶段的执行计划，会有不同的方法对逻辑执行计划和物理执行计划进行优化。为了精简，Blastoise去掉了逻辑执行计划这一环，也没有对物理执行计划做变换操作。但下面也会讲解在Blastoise的基础上，如何对执行计划做优化。下面，会先介绍迭代器，然后介绍各种迭代器的实现细节，以及它们如何一同完成增删改查的任务。然后会介绍如何从SQL解析树生成执行计划。最后会介绍一下优化的做法。

## 迭代器简介
迭代器是一种非常常用的设计模式，它为遍历操作提供了一个统一接口，隐秘了遍历细节。执行计划中最精妙的设计当属使用迭代器来实现。由于遍历细节和遍历接口得到分离，就可以使迭代器具有可随意组装的特性。迭代器都会实现一个最基本的接口，这个接口就是“取下一个值”操作。当这个取下一个值操作返回空的时候，就说明扫描任务已经结束。
这里主要拿查询操作来说明。对于SELECT * FROM STUDENTS WHERE score > 80这样的查询操作。如果是最简单的执行计划，首先需要做的操作就是对STUDENTS表进行全表扫描，这显然就是一个线性表的迭代器可以完成的。接下来需要做的就是对于每一个迭代器返回的表元组进行筛选操作，挑选出score字段大于80的表元组。筛选操作的迭代器是这样设计的，它内部保存对另外一个迭代器的引用，当它本身被要求取下一个值时，它首先要求对另一个迭代器取下一个元组操作，然后检查取到的元组是否满足筛选条件，如果不满足则继续要求另一个迭代器取下一个元组，继续筛选，直到找到一个满足筛选条件的，就返回。至此，一个全表扫描的迭代器和一个筛选迭代器就完成了这个查询操作的任务。而迭代器的可组装性质将会在接下来的各个迭代器的详细介绍中慢慢体现出来。

## 迭代器接口
Blastoise中，迭代器的接口除了有取下一个值操作，还有打开操作、关闭操作、打印相关信息操作、获取错误操作。打开操作是用于在迭代器开始前，申请一些任务需要用到的资源，例如把表数据从磁盘读入到内存池。而关闭操作则用于释放在打开操作中申请的资源，还有关闭所引用的迭代器。打印相关信息操作则用于查看一个迭代器所需要执行的任务的情况，类似于Mysql中的EXPLAIN操作。而获取错误操作是用于获取迭代器运行时发生的错误，这个错误不是指程序发生的错误，而是指一些在运行前，不能一开始就发现的错误。例如在插入一个数据的时候，有可能已经有相同主键的元组已经存在了，如果不做全表扫描，是不能发现这个错误的，因此需要有对这种错误的处理。如果一个迭代器有错误，那么它不能继续执行下去，而应该立即告诉用户操作失败了。

## 元组的具体实现
由于迭代器的实现部分牵涉到存储相关的细节，因此这里先作简要说明。元组的数据直接按字段的顺序紧凑地排列在一起，而这个数据排列结构在数据从磁盘转到内存中是不变的，因此对于元组，每个迭代器仅仅需要保存一份元组的描述，即所有字段的类型和所占空间的大小，还有该元组的指针即可。但是为了统一投影迭代器的返回结果，还是用了多个指针表示元组，下面投影迭代器将详细介绍。

## 各种迭代器介绍

### 全表扫描迭代器
全表扫描迭代器是最基本的迭代器，它用于查询操作。例如对于SELECT * FROM STUDENTS这样的SQL语句，就可以用一个全表扫描迭代器来实现。全表扫描迭代器的扫描操作是通过扫描内存池中的数据来实现的，因此在执行扫描之前，需要保证内存池中已经有了相关的数据。更确切来说，Blastoise的内存池是以页为单位的，整个扫描操作的基本过程是把磁盘中的数据以内存页为单位来处理，先从磁盘读一页数据进内存池，然后对该页数据做扫描，数据都扫描结束后放弃这一页然后获取下一页，再进行扫描操作。因此全表扫描迭代器的打开操作首先需要把表的第一页数据读进内存，这部分操作的细节将会在内存池部分再作详细说明。而关闭操作则需要确保把持有的内存页都全部释放。全表扫描迭代器内部需要维护一个索引值指向当前已经遍历到的元组位置，当下一次获取下一个元组时，需要根据这个索引值计算出下一个索引值是多少，并且在必要的时候要求内存池把数据从磁盘读入到内存中。接着只要把扫描得到的元组通过取下一个元组操作返回就可以了。当扫描结束时，迭代器返回空。

### 索引扫描迭代器
索引是用来加快扫描操作的一个非常有效的手段。虽然Blastoise没有实现索引，但为了展示迭代器的可组装的特性，这里需要对索引扫描迭代器作简要的接受。在查询操作中，性能的热点一般在于扫描迭代器，因为这是所有其它迭代器的数据源头，它的复杂度决定了整个查询操作的复杂度。因此关系型数据库的优化不少都是针对扫描操作的优化。建索引的基本思路是减少不必要的扫描。例如对于SELECT * FROM STUDENT WHERE ID = 5000。如果是哈希索引，则可以直接通过哈希表直接找出所找元组所在的位置。当然因为哈希文件也不小，所以载入到内存也需要一定的开销。如果是对ID这个字段做了B+树索引，由于B+树里面的元素是已经排好序的，所以首先这类似于把数组的查找转换为二叉排序树的查找。而此处优化的效果会好得多。因为扫描操作除了是费CPU外，不少时间也会用在磁盘的数据读取上。而如果使用了B+树索引，数据本身只需要读一次磁盘，因为可以通过B+树找到元组所在的位置。因此主要的磁盘消耗在于B+树数据的读取，由于B+树的性质，树的深度很浅，磁盘读取的次数也因此大大得到降低。
可见，索引扫描操作与全表扫描是实现上非常不一样，但利用了迭代器，索引扫描迭代器与全表扫描迭代器暴露了完全相同的接口，对于需要全表扫描迭代器完成的地方，完全可以把全表扫描迭代器无缝替换为索引扫描迭代器，而不用更改其它任何部分，这正体现了上述的迭代器的可组件化特性。

### 过滤迭代器
SQL语句中还需要支持对元组的过滤操作。过滤操作出现在SQL语句的两个地方，一个是WHERE子句，另一个是HAVING子句。拿WHERE子句来说，它会出现在全表扫描后面，当然如果需要对执行计划做优化的话，过滤迭代器出现的位置的情况则更为复杂。过滤迭代器的主逻辑是非常简单的，它需要持有对另一个迭代器的引用，现在称它为源数据迭代器，过滤迭代器通过调用源数据迭代的获取下一个元组操作获取元组，然后根据过滤条件筛去不需要的元组。更确切地说，在过滤迭代器的获取下一个元组的接口中，过滤迭代器会一直向源数据迭代器获取元组，并检查该元组是否能够通过过滤，如果找到一个可以了，就返回这个元组，如果没有找到则继续找。当然过滤迭代器的源数据迭代器也可以是另一个过滤迭代器。
由上面可以知道，过滤迭代器的主逻辑非常简单。然而上面还是省略了过滤的具体做法。在Blastoise中，过滤迭代器会关联一个条件表达式，然后在获取到元组数据后，就把元组上的字段数据抽出来，放到条件表达式中求值，如果求出来的值为真，就说明这个元组的数据通过了过滤，否则，则不通过。
因此过滤迭代器复杂的地方就在于逻辑表达式的求值。为了高效，在SQL中的条件表达式在被转换为解析树后，应该被转换成一种中间代码，例如把表示数字的字符串提前解析为数字。在Blastoise中为了简化问题，对逻辑表达式求值的部分是直接对条件表达式的语法树进行求值。求值的过程是递归整个条件表达式的语法树，如果遇到表示数字的字符串就把字符串转换成数字，如果遇到表字段，就根据表字段在元组数据中取出字段的值，这也要求了过滤迭代器需要存一份表字段的描述，这样才知道某个表字段的数据放在元组数据的哪个部分，长度是多少。接着遇到数学运算符就进行数学运算，遇到比较符就对比较进行运算，如果遇到与或表达式就计算与或表达式的结果，最后把运算的结果返回即可。

### 投影迭代器
SQL语句中往往只会选中感兴趣的字段的数据而不是所有字段，如SELECT ID FROM STUDENTS，只是保留了STUDENTS表的ID字段。这个操作叫做投影操作。投影操作的主逻辑本身也并不复杂，它根据对表字段的描述，还有需要投影的字段，把所需要的字段单独取出并返回。与过滤迭代器一样，投影迭代器也需要一个源数据的迭代器，它从元数据迭代器中取出数据，并进行投影操作。更确切地说，投影迭代器的获取下一个元组的接口的具体实现是，调用投影迭代器的获取下一个迭代器操作，然后进行取出所需要的字段，然后再返回新的元组数据。为了节省内存，Blastoise的投影操作并不是另开辟一片内容，然后把原来字段数据的排列的方式重新改变然后把必要的字段数据放到新内容中。为了解决的这个问题，元组数据被设计成是一个持有指针的数组，每个指针指向一个字段实际的数据位置。那么投影操作就变得什么简单且高效了，只要把不需要的字段对应的指针去掉，而且把需要字段对应的指针重新排序并返回即可。

## 增删改的实现
以上所介绍的迭代器都主要是查询用到的迭代器，确实在SQL语句中，其中最复杂的部分在查询部分，而且这部分使用的频率也是最多的，因为实际上SQL的增删改部分也需要用到查询，其实可以说增删改的主要工作还是查询。我们从增删改的顺序来一一介绍。
### INSERT语句
INSERT语句的作用是把一个元组的数据插入到表里面。这个问题看似是一个修改操作，然而它的大部分问题还是在查询上。因为在插入前必须保证这个元组的主键还没有被其它元组占用，因此在插入之前先要做一次查询操作，查找表中的主键是否已经存在。可见这还是一个查询的问题。之后的插入操作非常简单，在空位的地方插入元组即可，这个部分将在持久化部分详细说明。在实际实现的时候，用于实现插入语句的迭代器要先跑一遍查询语句，查看主键是否已经存在。
### DELETE语句
DELETE语句一般都是加上WHERE子句，而不是把表里面所有元组都删除。因此在删除元组前，需要找到元组所在的位置，因此DELETE语句的在执行之前也要先做一遍遍历和筛选。在实现上有个问题，就是获取到要删除的元组后要怎么删除，一种方法是记录所扫描到的元组的索引，但一种更取巧的方法是，在得到指向元组数据的指针后，利用指针来算出元组所在的位置，这样就不用去维护索引，从而降低了实现的复杂程度。
### UPDATE语句
UPDATE语句则与DELETE语句类似，也是需要先对表做一遍扫描和筛选后，得到指向元组数据的指针后，然后直接修改指针指向的数据。在实现上，UPDATE语句需要持有一个源数据迭代器，该源数据迭代器就是一个扫描迭代器和筛选迭代器来实现查询的功能。

## 执行计划的优化
以迭代器为基础实现的执行计划也是非常易于做优化的，如前面提到的可以用索引扫描迭代器无缝替换全表扫描迭代器。虽然Blastoise没有实现执行计划的优化，但为了说明迭代器这种设计在实现执行计划中的作用，下面将继续对执行计划的优化作说明。
上文已经提及了利用索引优化全表扫描，这里不再重复。另外一个比较大的性能问题是联表查询，因为要对多个表的所有元组做笛卡尔积，而且在做笛卡尔积的同时还要反复把数据从磁盘换到内存，然后因为内存不够又把这部分数据丢弃，然后下一次用到的时候还要再把这些数据换回到内存。首先当然可以用索引的办法来分别优化每张表的遍历操作。然后也可以通过把相对较小的表放入内循环来让小表不需要重复把磁盘的数据放入内存。然后是对于自然链接，可以使用更高效的合并连接，合并连接有点类似于两个有序数组做归并，归并后还是有序，利用的还是B+树索引的有序性。这个时候实现归并操作的迭代器需要两个源数据迭代器，这两个迭代器会不断按照自然链接的字段的顺序来返回元组，这样做归并连接的迭代器就可以实现归并连接了。由此可见，迭代器是实现执行计划的一个非常有效的方案。
