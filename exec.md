# 执行计划
用户输入的SQL语句被转换成解析树，并通过语义检查后，就会被转换为执行计划。生成执行计划的过程中将会有大量的优化操作。在Blastoise中为了精简，仅仅实现了生成执行计划，略去了对执行计划的转换。一般来说，执行计划仅仅适用于增删改查的操作，但在Blastoise中，为了内部实现的统一，创建表和删除表也统一用执行计划来实现。前文提到，执行计划分为逻辑执行计划和物理执行计划，对于生成这两个阶段的执行计划，会有不同的方法对逻辑执行计划和物理执行计划进行优化。为了精简，Blastoise去掉了逻辑执行计划这一环，也没有对物理执行计划做变换操作。但下面也会讲解在Blastoise的基础上，如何对执行计划做优化。下面，会先介绍迭代器，然后介绍各种迭代器的实现细节，以及它们如何一同完成增删改查的任务。然后会介绍如何从SQL解析树生成执行计划。最后会介绍一下优化的做法。

## 迭代器简介
迭代器是一种非常常用的设计模式，它为遍历操作提供了一个统一接口，隐秘了遍历细节。执行计划中最精妙的设计当属使用迭代器来实现。由于遍历细节和遍历接口得到分离，就可以使迭代器具有可随意组装的特性。迭代器都会实现一个最基本的接口，这个接口就是“取下一个值”操作。当这个取下一个值操作返回空的时候，就说明扫描任务已经结束。
这里主要拿查询操作来说明。对于SELECT * FROM STUDENTS WHERE score > 80这样的查询操作。如果是最简单的执行计划，首先需要做的操作就是对STUDENTS表进行全表扫描，这显然就是一个线性表的迭代器可以完成的。接下来需要做的就是对于每一个迭代器返回的表元组进行筛选操作，挑选出score字段大于80的表元组。筛选操作的迭代器是这样设计的，它内部保存对另外一个迭代器的引用，当它本身被要求取下一个值时，它首先要求对另一个迭代器取下一个元组操作，然后检查取到的元组是否满足筛选条件，如果不满足则继续要求另一个迭代器取下一个元组，继续筛选，直到找到一个满足筛选条件的，就返回。至此，一个全表扫描的迭代器和一个筛选迭代器就完成了这个查询操作的任务。而迭代器的可组装性质将会在接下来的各个迭代器的详细介绍中慢慢体现出来。

## 迭代器接口
Blastoise中，迭代器的接口除了有取下一个值操作，还有打开操作、关闭操作、打印相关信息操作、获取错误操作。打开操作是用于在迭代器开始前，申请一些任务需要用到的资源，例如把表数据从磁盘读入到内存池。而关闭操作则用于释放在打开操作中申请的资源，还有关闭所引用的迭代器。打印相关信息操作则用于查看一个迭代器所需要执行的任务的情况，类似于Mysql中的EXPLAIN操作。而获取错误操作是用于获取迭代器运行时发生的错误，这个错误不是指程序发生的错误，而是指一些在运行前，不能一开始就发现的错误。例如在插入一个数据的时候，有可能已经有相同主键的元组已经存在了，如果不做全表扫描，是不能发现这个错误的，因此需要有对这种错误的处理。如果一个迭代器有错误，那么它不能继续执行下去，而应该立即告诉用户操作失败了。

## 各种迭代器介绍
### 全表扫描迭代器
全表扫描迭代器是最基本的迭代器，它用于查询操作。例如对于SELECT * FROM STUDENTS这样的SQL语句，就可以用一个全表扫描迭代器来实现。
