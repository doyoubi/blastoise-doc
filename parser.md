# SQL解析与语义检查

## 词法分析

用户输入的SQL语句作为字符串首先要被转换为单词(Token)串，这是词法分析的任务。在Blastoise中，单词的类型有整型数字、浮点型数字、字符串、标识符、关键字（如Select）。Blastoise参照了传统的词法分析方法，即用有限自动机来识别单词类型。对于不同的单词类型，使用不同的状态机来识别他们，但其中整型数字会跟浮点型数字合起来一起处理，标识符和关键字使用的是同一个状态机，在识别出一个标识符后，通过判断单词内容是不是关键字来决定要不要把这个单词归类为关键字。
最终，所有单词类型的状态机需要被合并到一起，来组成识别所有单词类型的大状态机。

### 整型与浮点型数字
通常整型和浮点型数字会被放在一起处理，我们将先单独看看单独处理整型和浮点型的状态机是怎么样的，再来解释为什么要把他们放到一起。  
![整型状态机](./parser-pic/pure-int-fsm.jpg)  
整型状态机是非常简单的状态机，从起始状态如果遇到数字字符就进入InInteger状态，如果继续遇到数字字符，则停留在InInteger状态，如果遇到非数字字符就进入终结状态，并把这个这个过程中遇到的所有数字字符串截取下来，从而获得整型数字的单词。
![浮点型状态机](./parser-pic/pure-float-fsm.jpg)  
浮点型状态机则复杂一点，首先需要有一串数字字符，然后是一个'.'字符，然后再是一串数字字符。这里有个问题，上面那个状态机对于“12.”这样的点后面没有数字的字符串，也会认为他是一个表示浮点型的单词。事实上，不少编程语言的规范中，也认为这样的字符串是合法的浮点型单词。然而Blastoise还是去掉了这种反直觉的情况。这样上面的状态机就需要把InFloat状态分裂成两个状态，在中间状态遇到点字符会进入InFloat1状态，InFloat1遇到数字字符会转到InFloat2状态，InFloat2状态遇到数字字符则停留，遇到其它字符则进入终结状态。在Blastoise中，采用了另一种更便捷的方法来规避这种把状态机弄复杂的做法。在程序中，当状态由中间状态变成InFloat状态时，会检查点字符后面的字符是否为数字字符，如果不是，则直接报错。这样的程序虽然不是一个很严格的有限自动机程序，因为它需要向后预先查看字符，但其实严格准守有限自动机并不会带来什么好处。

事实上通过观察整型状态机和浮点型状态机，我们很容易看出来，整型状态机完全可以嵌入到浮点型状态机中。  
![整型-浮点型状态机](./parser-pic/int-float-fsm.jpg)  
这样，这个状态机就可以同时处理整型和浮点型。如果不这么做，在合并整型状态机和浮点型状态机的时候就会有问题。具体来说，在遇到一串数字字符的时候，就不知道当前状态应该是整型状态机的InInteger还是浮点型状态机的中间状态。这个时候要么提前向后搜点字符，要么在发现状态机错误的时候回溯，无论哪种都非常麻烦，因此合并整型和浮点型状态机是十分需要的。

### 字符串
字符串与其他单词一个很明显的不同是，单词两边的字符肯定是'"'。  
![字符串状态机](./parser-pic/string-fsm.jpg)  
在遇到引号字符时，进入InString状态，再次遇到引号字符时，进入终结状态。值得注意的是，还需要处理转义字符。例如需要支持换行字符。这时需要增加多一个InStringEscaping的状态，如果遇到了反斜杠，则进入InStringEscaping状态，在这个状态中，如果遇到合法的转义字符，例如换行符n，则把两个\n字符转换为换行符，并转为InString状态。如果遇到非合法的转移字符则报错。

### 标识符
标识符是开头为英文字符或下划线的单词，它只能包含英文字符、下划线和数字。限制开头为英文字符和下划线，是为了在于合并状态机的时候，可以与整型-浮点型状态机区分开。
![标识符状态机](./parser-pic/identifier-fsm.jpg)  

### 关键字
关键字可以使用标识符的状态机，然后在生成单词的时候，可以判断内容是否为关键字来把标识符转换成关键字。


## 语法分析

在词法分析阶段获得单词序列后，就需要将其转换为解析树。Blastoise使用了递归下降的自顶向下方法对SQL的单词串进行解析。由于SQL语句的文法大部分都是SLL(1)，因此解析这部分文法比较容易，下文对这部分将只以SELECT语句为例。而比较复杂的在于WHERE子句中的条件表达式的解析，下文将着重说明解析条件表达式所遇到的问题以及解决方法。在介绍解析SQL单词串前，本文先对递归下降作简要说明。

### 递归下降法
递归下降法作为一种简单有效的语法分析方法一直被广泛利用。因为一般解析程序往往不是软件系统的效率瓶颈，因此往往不需要考虑解析程序的性能问题。而递归下降的好处是易于实现且当文法有改动的时候，也可以很方便地修改程序以适应新文法。
递归下降最基本的思想是，使用一个指针指向单词串中的单词，指针一开始指向第一个单词。然后尝试去匹配文法。如果文法匹配成功则把指针向后移动，然后尝试匹配子文法，如果又能匹配成功就继续移动指针。如果文法匹配不成功则换其它文法尝试。当所有子文法都匹配完成时，如果指针恰好指向单词串的末端，则说明刚才的解析路径已经成功解析单词串，最终可得到解析树。如果此时还有其他单词串未被解析，则说明该路径是错误的，继续回溯，换其它文法尝试。

### SELECT语句的解析
SELECT语句的文法如下：
select_statement ::= SELECT select_expr
                     FROM relation_list
                     [WHERE condition]
                     [
                        GROUP BY table_attribute
                        [HAVING condition]
                     ]
                     [ORDER BY attribute]
解析SELECT语句时，一开始会识别SELECT这个关键字，如果第一个单词不是SELECT关键字，则会立即报错。之后会尝试识别 select_expr。识别完之后会找FROM关键字，之后是解析relation_list。对于接下来几个可选项，如果接下来的指针所指的单词是WHERE，则说明有WHERE子句，继续解析WHERE子句中的条件表达式。如果有GROUP BY则解析table_attribute，还有尝试查看是否有HAVING子句。最后尝试看看有没有ORDER BY子句。
明显可以看到，SELECT在设计的时候全都使用了SLL(1)文法，解析的时候只要简单看看后一个单词的类型，就可以知道接下来要怎么解析。更不需要像LL(1)那样去算FIRST集和FOLLOW集，大大降低了解析程序的复杂度。
但无可避免的是，WHERE子句中的条件表达式依然是使用了人们最常用的数学语言，而数学语言并不是简单的SLL(1)，而这部分的文法实现则复杂得多。

### 列表结构
在处理条件表达式之前，我们先对解析列表结构进行说明。因为该结构非常常见。这里所说的列表结构指“元素 分隔符 元素 分隔符 元素”这样的结构。它可以是更长的列表。分隔符往往都是一样的，而元素可以是多种多样的。拿SELECT语句中的select_expr来说，如果SELECT *的情况，select_expr就是一个表名列表，这个列表的分隔符是逗号，元素是标识符。我们将给出一个解析列表结构的通用方法。
在给出算法之前，先考虑两个个细节问题。首先是列表不能为空，这是递归下降锁要求的产生式右边不可以是空串。另外这也是SQL语句的语义所要求的，所有SQL的文法中不会有空的列表。另外，列表的结尾只能是元素，而不能是分隔符，这是我们的文法所要求的。
首先列表结构的文法是：
列表 ::= 元素 重复 | 元素  
重复 ::= 分隔符 元素 重复 | 分隔符 元素  
确实这也可以直接用递归下降的方法来解析，但这需要做回溯。事实上Blastoise用了一种更简便的方法来解析列表结构。这种做法首先解析第一个元素，然后提前看看后一个单词是什么类型，如果后面没有单词则成功返回，如果后面的单词不是分隔符，也成功返回，如果后面的单词是分隔符，则解析分隔符还有分隔符后面的元素，并将元素和分隔符加入到解析树。这种做法并不是严格的递归下降的做法，因为递归下降不会提前去看后一个单词。但实际上严格准守递归下降的做法也并没有什么好处，对递归下降稍作修改如果可以很好地解决问题也应该是鼓励的。加入提前向后看单词后，解析列表结构的程序将被大大简化而且变得更加紧凑。而且文法也可以变成这样：
列表 ::= 元素 [分隔符 元素]*
[]以内表示重复的内容，*表示重复0次以上。这虽然不是严格的文法写法，但却可以与上述解析算法相匹配，它可以很好地描述列表结构并大大简化问题并让问题变得更直观。
列表结构在SQL文法中多处出现，例如刚刚说到的select_expr，还有FROM子句中的relation_list，CREATE TABLE 中的属性定义，还有四则运算表达式中的连续加减乘除（这时分隔符就是四则运算符号）。

### 条件表达式
条件表达式是解析SQL语句中最复杂的一部分，在最复杂的情况下，条件表达式会被解析成一棵很深的解析树，它的元素包括各种类型的常量还有标识符。此外，条件表达式文法的设计还会牵涉到后面的语义检查，Blastoise使用了一种技巧通过调整文法从而减少一些类型检查。
条件表达式最上层是与或表达式，接下来是比较表达式，最下面运算表达式。接下来将以运算表达式和与或表达式为例解析条件表达式中的一些解析做法，另外的表达式的解析问题都可以用相同的办法来实现。

### 二元表达式
条件表达式中存在大量的二元表达式，例如 true or false, 1 < 2, 1 + 1。因此一个很重要的问题就是解析二元表达式。事实上，虽说是二元表达式，但是操作数并不一定需要是两个的。对于1 + 1和1 + 1 + 1的情况，是可以合并一起来处理的。这时可以明显地看到这实际上就是上述的列表结构，因此二元表达式的解析就完全可以用解析列表的算法来解决。不过这里有个地方需要在意的是，由于运算符有运算顺序的问题，因此在解析1 + 2 + 3时，1 + 2应该作为顶树的左子树，3为右子树。
接下来是运算符优先级的问题，生成的解析树需要遵守运算符的优先级。这里以与或表达式为例。例如 a or b and c。生成的解析树中，a or b应该是左子树，c为右子树，因为and的运算优先级要高。而实现这种优先级的方法是在文法的设计上。如果是加减法这种两个运算符平级的情况里面，加减法的文法都可以写在一起，而当有优先级要求的时候，就不可以了。例如：
与或表达式 ::= a or a | a and a
是不能体现优先级的，上述的文法需要被修改为
或表达式 ::= 与表达式 or 与表达式
与表达式 ::= a and a
这样保证了所有的与表达式都是或表达式的子树，从而保证了与表达式的优先级。

### 减少类型检查工作
在生成解析树后，需要对条件表达式中的一元和二元运算符做类型检查。例如 字符串 != 1234 是非法的，字符串只能和字符串比较，数字只能和数字比较。类型检查是非常繁琐的，而良好的文法设计能够减少类型检查的工作，让类型匹配问题在语法分析阶段就能被查出来。Blastoise的做法是，首先在文法上禁止了运算符的操作数只能是整型和浮点型，这样就防止了除了对字符串进行数学运算的情况。然后在比较运算符中，只留了字符串类型和null类型，整型和浮点型都放到了数学表达式的子文法中。当检查比较表达式的时候，如果表达式其中一个操作数是字符串，那么仅仅检查数学表达式是否只由一个表字段组成，并检查表字段是否为字符串类型就可以了，这样就减少了类型检查需要做的情况。

### Rust写词法分析和语法分析
在使用Rust实现词法分析和语法分析的过程中，发现Rust十分适合完成他们。首先词法分析中其中蕴含很多模式匹配的问题，而Rust本身就自带了模式匹配。因此写起词法分析来十分方便。而在语法分析中，Rust的错误处理机制也很适合用来做语法分析的错误管理。Rust的宏不同于C/C++，本身就自带了一定程度的类型约束，使用起来也不容易出错，Blastoise用Rust的宏来实现二元表达式，省去了不少重复的代码。

## 语义检查
在得到解析树后，虽然是满足文法的，但是不一定满足语义，例如前文提到的用字符串和整型来做相等比较。这些语义的规则不一定都能通过精心设计文法来保证。这时候，就需要在后面再加多一个语义检查的阶段。在SQL语句的语义检查包括了对表、表字段是否存在的检查，字段名是否明确的检查，还有条件表达式中的类型检查。接下来首先对类型检查进行说明，然后再解决表名和字段名的问题。

### 类型检查
类型检查最基本的就是对于所有的运算符，不管是一元还是二元，都检查其操作数是否合法或者匹配。这里分两种情况，一种是操作数是字面量的情况，另一种是操作数是表字段的情况。对于前者，只要检查字面量类型就可以了，但对于后者，我们还需要获取表字段的类型。

### 字段名的模糊问题
如果两张表都拥有一个具有相同名字的字段，而在SELECT语句中都引用了这张表，而引用了这个两张表都有同名字段的名字，那么就不能分清所引用的名字究竟指的是那张表中的字段。所以一个字段其实更精确的表述是一个表和字段名的二元组。Blastoise支持了只写字段名的写法。因此也需要在语义检查中检查字段名是否是模糊的问题。

### 字段名的补全
上面的问题提到，字段更精准的表述是表和字段名的二元组，而由于Blastoise支持只写字段名的做法，因此，为了方便后面的所有操作，在做语义检查的时候，Blastoise对字段名做了补全，如果字段没标明表名，Blastoise会算出它所在的表，并补上标明。这种做法虽然让本来应该是幂等的语义检查操作变成是有副作用的，但字段名补全的操作跟语义检查很类似，都要递归遍历表达式的所有子树，因此很适合一边做语义检查，一边顺便补全字段名。

### 表名、字段名是否存在
语义检查的一个重要问题就是检查标识符是否是合法的字段名，这就需要获取现有表的素有字段信息。Blastoise的做法是另外生成一份表和字段名的数据来供检查使用。不直接访问表和字段名的数据是因为如果数据库需要拓展为多线程，频繁读中心数据必然会引起频发加锁解锁的问题，而生成一份数据副本则不会有这样的问题。

### Group By 字段检查
虽然Blastoise没有实现Group By，但是文法上还是实现了。对Group By也需要做语义检查，例如一些聚合函数的字段必须是Group By子句中指定的字段，还有Having子句中的条件表达式中的字段也必须是Group By中的字段。
